= The Internet Identity Specification
:toc2:
:toclevel: 4
:sectanchors:

== Introduction

This document describes and specifies the Internet Identity from various angles and at various levels of abstraction, namely:

 * High level goals, requirements and use cases
 * Overview of the security and identity machinery, including the interplay of identities, keys, and delegations
 * Interface as used by client applications frontends, i.e., the OAUTH-based spec
 * The interface of the Internet Identity Service _backend_, i.e., describing its contract at the Candid layer, as used by its frontend
 * Important implementation notes about the Internet Identity Service backend
 * Internal implementation notes about the Internet Identity Service frontend

The Internet Identity Service consists of

 * an index canister, orchestrating and scaling out the set of backend canisters
 * one or more backend canisters
 * the frontend, a web application served by an otherwise stateless canister with a _well-known_ canister id

Similarly, the client applications consist of a frontend (served by a canister) and (typically) one or more backend canisters. Only the client application frontend interacts with the Internet Identity Service directly (via the OAUTH protocol described below).

== Goals, requirements and use cases

The Internet Identity service allows users to

 * maintain identities on the Internet Computer
 * log into these identities using one out of a set of security devices
 * manage this set of security devices

Some functional requirements are

 * users have separate identities per client application (more precisely, per client application frontend "hostname")
 * these identities are stable, i.e., do not depend on a user's security devices
 * the client frontends interact with any canister on the Internet Computer under the user‚Äôs identity with that frontend
 * users do not need ever to remember secret information (but possibly per-user non-secret information)
 * the security device does not need to be manually touched upon every interaction with a client application; a login is valid for a certain amount of time per identity

Some security requirements are

* The separate identities of a single user cannot be related merely based on their public key or principal ids, to impede user tracking.
* (many more, of course; apply common sense)

Some noteworthy security assumptions are:

* The delivery of frontend applications is secure. In particular, a user accessing the Internet Identity Service Frontend through a TLS-secured HTTP connection cannot be tricked into running another web application.

* The security devices only allow the use of their keys from the same web application that created the key (in our case, the Internet Identity Service Frontend).

* The Internet Identity Service backend can keep a secret.
+
(This assumption is only used relied on for the privacy aspect.)


== Identity design and data model

The Internet Computer serves the frontend under hostname `https://identity.ic0.app`.

Each backend canister exclusively controls the identities of a set of users.

A user account is identified by a unique _user number_, a smallish natural number chosen by the canister.

A client application frontend is identified by its hostname (e.g., `abcde-efg.ic0.app`, `nice-name.ic0.app`, `non-ic-application.com`). Frontend application can be served by canisters or by websites that are not hosted on the Internet
Computer.

A backend canister maintains a secret salt (in the following the `salt`), a 32 byte long blob that is obtained via the Internet Computer‚Äôs source of secure randomness.

A user has a separate _user identity_ for each client application frontend (i.e., per hostname). This identity is a https://docs.dfinity.systems/public/#id-classes[_self-authenticating id_] that is derived from a https://hydra.dfinity.systems/latest/dfinity-ci-build/ic-ref.pr-319/interface-spec/1/index.html#canister-signatures[canister signature] public ‚Äúkey‚Äù based on the `ii_canister_id` and a seed of the form
....
H(|salt| ¬∑ salt ¬∑ |user_number| ¬∑ user_number ¬∑ |frontend_host| ¬∑ frontend_host)
....
where `H` is SHA-256, `¬∑` is concatenation, `|‚Ä¶|` is the length of `‚Ä¶` in bytes, `user_number` is the ASCII-encoding of the user number as a decimal number and `frontend_host` is the ASCII-encoding of the client application frontend‚Äôs hostname.

A Internet Identity Service backend canister stores the following data in user accounts, indexed by the respective user number:

* a set of _device information_, consisting of
- the device‚Äôs public key (DER-encoded)
- a device _alias_, chosen by the user to recognize the device
- an optional _credential id_, which is necessary for WebAuthN authentication

When a client application frontend wants to log in as a user, it uses a _session key_ (e.g., Ed25519 or ECDSA), and by way of the OAUTH protocol (details below) obtains a https://docs.dfinity.systems/public/#authentication[_delegation chain_] that allows the session key to sign for the user‚Äôs identity.

This delegation chain consists of one delegation, called the _client delegation_. It delegates from the user‚Äôs identity (for the given client application frontend) to the session key. This delegation is created by the Internet Identity Service backend canister responsible for this user, and signed using a https://hydra.dfinity.systems/latest/dfinity-ci-build/ic-ref.pr-319/interface-spec/1/index.html#canister-signatures[canister signature]. This delegation is unscoped (valid for all canisters) and has a lifetime of *TODO*.

The Internet Identity Service Frontend, while a user is logged in, manages a _identity frontend delegation_, delegating from the security device‚Äôs public key to a session key managed by this frontend, so that it can interact with the backend without having to invoke the security device for each signature.

[#oauth]
== OAUTH protocol

This section describes the Internet Identity Service from the point of view of a client appliation frontend (a.k.a. the relaying party).

The client application frontend creates a session key pair (e.g., Ed25519). It then redirects the user to the Internet Identity Service Canister frontend, more concretely to the URL

  https://identity.ic0.app/authorize?‚Ä¶

with URL parameters as specified by the OAUTH protocol. Of particular interest is the parameter

* the `login_hint` parameter contains the public key of the session key created by the client application frontend, as a hex-encoded DER key.

* the `redirect_uri`, the hostname of which is used to identify the client application frontend‚Äôs hostname.

If the Internet Identity Service Frontend can authorize this request, the url parameters on the callback (i.e., the provided `redirect_uri`) contain in particular

* the `accessToken`, which is the hex-encoding of a JSON encoding of the delegation chain in the following format
+
....
{
  delegations: [
    { delegation: {
        expiration: (hex-encoded big-endian expiration date)
        pubkey: (hex-encoded DER-encoded public key of delegatee)
        targets: (optional)
          [ (hex-encoded binary canister id)
            ‚Ä¶
          ]
      },
      signature: (hex-encoded signature)
    }
    ‚Ä¶
  ],
  publicKey: (hex-encoded public key underlying the user identity))
}
....
+
This structure can be converted by the client application into a CBOR-encoded delegation chain as used for https://docs.dfinity.systems/public/#authentication[_authentication on the IC_].

The client application frontend needs to be able to detect when any of the delegations in the chain has expired, and re-authorize the user in that case.

The https://www.npmjs.com/package/@dfinity/authentication[`@dfinity/authetication` NPM package] provides functionality for this workflow.

The client application frontend should support delegation chains of lenght more than one, and delegations with `targets`, even if the present version of this spec does not use them, to be compatible with possible future versions.

== The Internet Identity Service index canister

This section describes the interface and behaviour provided by the index canister

....

type UserNumber = nat64;
// half-closed interval, inclusive lower, exclusive upper bound
type UserNumberRange = record { UserNumber; UserNumber };

type BackendInfo = record {
  canister_id : principal;
  range : UserNumberRange;
}

service : {
  act : () -> ();
  backends : () -> (vec BackendInfo) query;
}
....

As state (backed by stable memory to be upgrade safe), the index canister maintains a list of `BackendInfo`, ordered by their user number range. This data also includes, for each canister, the hash of the wasm module installed there.

The index canister also has, as static data, the latest backend caniser wasm module.

TODO: Insights/logging (e.g. recording installation/upgrade failures, insightes into ongoing processes).

=== The `act` method

This method, which is executed regularly, lets the index canister perform its work.

NOTE: TODO how often this `act` method needs to be called, and whether we need to restrict access, and to whom. Alternatively, https://github.com/dfinity-lab/ic-ref/issues/245[Heartbeat messages] can be used once available.

* The index canister checks if the last canister is more than 50% full (using `stats`), and if so, creates and installs a new backend canister.
+
The controller of the backend canister is the index canister.+
+
NOTE: Once and if the System supports https://github.com/dfinity-lab/ic-ref/issues/314[multiple controllers], the NNS governance canister will be set as an additional controler, to allow emergency interventions (e.g. stopping, upgrading) via NNS proposals.
+
The new canister is assigned the next range of user numbers.
+
Because of the asynchronous nature of canister installation, it must set a flag to not do this multiple times in parallel. The canister must be written defensively to clear this flag if installation fails (e.g. `ic0.call_on_cleanup`) and thus retry.
+
Once `install_code` comes back successfully, it can include the canister in the response to `backends()`.

* For each canister with a wasm module hash that does not match the hash of the wasm module, an upgrade (without stopping, since backend canisters do not perform calls) is performed.
+
Like above, this needs to be guarded with a flag ‚Äúin process‚Äù and defensive handling of failures.

The upgrade procedure for the whole system is to upgrade the index canister with the new backend canister module, and then let the index canister upgrade all backend canisters.

=== The `backends` query method

This query method returns information about successfully installed canisters.

== The Internet Identity Service Backend interface

This section describes the interface that the backend canister provides.

This interface is currently only used by its own frontend. This tight coupling means that this interface may change, even in incompatible ways. We therefore do not have to apply Candid best practices for backward-compatibility (such as using records for arguments and results).

The summary is given by the following Candid interface (exluding the methods required for the https://www.notion.so/Design-HTTP-Requests-to-Canisters-d6bc980830a947a88bf9148a25169613[HTTP Gateway interface]):
....
type UserNumber = nat64;
type PublicKey = blob;
type CredentialId = blob;
type DeviceAlias = text;
type DeviceKey = PublicKey;
type UserKey = PublicKey;
type SessionKey = PublicKey;
type FrontendHostname = text;
type Timestamp = nat64;

type DeviceData = record {
  pubkey : DeviceKey;
  alias : text;
  credential_id : opt CredentialId;
};
type RegisterResponse = variant {
  success: UserNumber;
  canister_full;
};

type Delegation = record {
  pubkey: SessionKey;
  expiration: Timestamp;
  targets: opt vec principal;
};
type SignedDelegation = record {
  delegation: Delegation;
  signature: blob;
};
type GetDelegationResponse = variant {
  signed_delegation: SignedDelegation;
  no_such_delegation;
};

type ProofOfWork = record {
  timestamp : Timestamp
  nonce : nat64
};


service : {
  init_salt : () -> ();
  register : (DeviceData, ProofOfWork) -> (RegisterResponse);
  add : (UserNumber, DeviceData) -> ();
  remove : (UserNumber, DeviceKey) -> ();
  lookup : (UserNumber) -> (vec DeviceData) query;

  prepare_delegation : (UserNumber, FrontendHostname, SessionKey) -> (UserKey, Timestamp);
  get_delegation: (UserNumber, FrontendHostname, SessionKey, Timestamp) -> (GetDelegationResponse) query;
}
....

The `init_salt` method is mostly internal, see <<salt>>.

=== The `register` method

The `register` method is used to create a new user. The Internet Identity Service backend creates a _fresh_ user number, creates the account record, and adds the given device as the first device.

*Authorization*: This request must be sent to the canister with `caller` that is the self-authenticating id derived from the given `DeviceKey`.

In order to protect the Internet Computer from too many ‚Äúfree‚Äù update calls, and to protect the Internet Identity Service from too many user registrations, this call is protected using a proof of work obligation. The `register` call can only succeed if

 * the `timestamp` in the `ProofOfWork` parameter is within 5min of the current time as seen by the Canister
 * the calculation of `H("\10ic-proof-of-work" ¬∑ timestamp ¬∑ nonce ¬∑ |cid| ¬∑ cid )` (where `H` is the https://cubehash.cr.yp.to/[CubeHash160+16/32+160-256] function, `¬∑` is concatenation, `|‚Ä¶|` is a single byte encoding the length of the raw canister id in bytes, `cid` is the canister id and numbers are encoded as 8-byte little endian values), yields a hash value where leading 2 bytes are `0x00`.
 * the canister did not recently see a registration attempt with that `nonce`.

If this backend canister is full, it replies with `canister_full`.

=== The `add` method

The `add` method appends a new device to the given user‚Äôs record.

The Internet Identity Service backend rejects the call if the user already has a device on record with the given public key.

This may also fail (with a _reject_) if the user is registering too many devices.

*Authorization*: This request must be sent to the canister with `caller` that is the self-authenticating id derived from any of the public keys of devices associated with the user before this call.

=== The `remove` method

The `remove` method removes a device, identified by its public key, from the list of devices a user has.

It is allowed to remove the key that is used to sign this request. This can be useful for a panic button functionality.

It is allowed to remove the last key, to completely disable a user. The canister may forget that user completely then, assuming the user number generation algorithm prevents new users from getting the same user number.

It is the responsibility of the frontend UI to protect the user from doing these things accidentally.

*Authorization*: This request must be sent to the canister with `caller` that is the self-authenticating id derived from any of the public keys of devices associated with the user before this call.

=== The `lookup` query method

Fetches all data associated with a user.

*Authorization*: Anyone can call this

=== The `prepare_delegation` method

The `prepare_delegation` method causes the Internet Identity Service backend to prepare a delegation from the user identity associated with the given user number and Client Application Frontend Hostname to the given session key.

This method returns the user‚Äôs identity that‚Äôs associated with the given Client Application Frontend Hostname. By returning this here, and not in the less secure `get_delegation` query, we prevent attacks that trick the user into using a wrong identity.

The method returns the expiration timestamp of the delegation. This is returned purely so that the client can feed it back to the backend in `get_delegation`.

The actual delegation can be fetched using `get_delegation` immediately afterwards.

*Authorization*: This request must be sent to the canister with `caller` that is the self-authenticating id derived from any of the public keys of devices associated with the user before this call.


=== The `get_delegation` query method

For a certain amount of time after a call to `prepare_delegation`, a query call to `get_delegation` with the same arguments, plus the timestamp returned from `prepare_delegation`, actually fetches the delegation.

Together with the `UserKey` returned by `prepare_delegation`, the result of this method is used by the Frontend to form the `accessToken` in the <<oauth,OAUTH flow>>.

*Authorization*: Anyone can call this

== The Internet Identity Service backend internals

This section, which is to be expanded, describes interesting design choices about the internals of the Internet Identity Service Canister. In particular

[#salt]
=== The salt

The `salt` used to blind the hashes that form the `seed` of the Canister Signature ‚Äúpublic keys‚Äù is obtained via a call to `aaaaa-aa.raw_rand()`. The resulting 32 byte sequence is used as-is.

Since this cannot be done during `canister_init` (no calls from canister init), the randomness is fetched by someone triggering the `init_salt()` method explicitly, or just any other update call. More concretely:

* Anyone can invoke `init_salt()`
* `init_salt()` traps if  `salt != EMPTY_SALT`
* Else, `init_salt()` calls `aaaaa-aa.raw_rand()`. When that comes back successfully, and _still_ `salt == EMPTY_SALT`, it sets the salt. Else, it traps (so that even if it is run multiple times concurrently, only the first to write the salt has an effect).
* _all_ other update methods, at the beginning, if `salt == EMPTY_SALT`, they await `self.init_salt()`, ignoring the result (even if it is an error). Then they check if we still have `salt == EMPTY_SALT` and trap if that is the case.

=== Why we do not use `canister_inspect_message`

The system allows canisters to inspect ingress messages before they are actually ingressed, and decide if they want to pay for them (see https://docs.dfinity.systems/public/#system-api-inspect-message[the interface spec]). Because the Internet Identity canisters run on the NNS subnet, cycles are not actually charged, but we still want to avoid wasting resources.

It seems that this implies that we should use `canister_inspect_message` to reject messages that would, for example, not pass authentication.

But upon closer inspection (heh), this is not actually useful.

 * One justification for this mechanism would be if we expect a high number of accidentally invalid calls. But we have no reason to expect them at the moment.

 * Another is to protect against a malicious actor. But that is only useful if the malicious actor doesn‚Äôt have an equally effective attack vector anyways, and in our case they do: If they want to flood the NNS with calls, they can use calls that do authenticate (e.g. keeping removing and adding devices, or preparing delegations); these calls would pass message inspection.

On the flip side, implementing `canister_inspect_message` adds code, and thus a risk for bugs. In particular it increases the risk that some engineer might wrongly assume that the authentication checkin `canister_inspect_message` is sufficient and will not do it again the actual method, which could lead to a serious bug.

Therefore the Internet Identity Canister intentionally does not implement `canister_inspect_message`.

=== Internal data model and data structures used

The primary data structure used by the backend is a map from user number to the list of user devices.
Device lists are stored directly in canister stable memory.
The total amount of storage for is limited to 510 bytes per user.
With the stable memory size of 4GiB we can store around 8 * 10^6 user records in a single canister.

There is also a set of recently seen proof of work nonces.

==== Stable memory layout

All the integers (u64, u32, u16) are encoded in Little-Endian.
....
Storage ::= {
  Header
  UserRecords
}

Header ::= {
  magic : u8[3] = "IIC"
  version : u8 = 1
  number_of_user_records : u32
  user_number_range_lo : u64
  user_number_range_hi : u64
  entry_size: u16
  salt: u8[32]
  padding : u8[454]
}

UserRecords ::= UserRecord*

UserRecord ::= {
  size : u16
  candid_bytes: u8[510]
}
....

User record for user number N is stored at offset `sizeof(Header) + (N - user_number_range_lo) * sizeof(UserRecord)`.
Each record consists of a 16 bit `size` ‚àà [0..510] followed by `size` bytes of Candid-serialized list of devices.

....
type UserDeviceList = vec(record {
  pubkey : DeviceKey;
  alias : text;
  credential_id : opt CredentialId;
});
....

==== Proof of work nonces

In order to implement `register` as specified above, the Canister maintains the set of `nonce` values that were used recently (last 10 minutes) in a call to `register`.

The proof of work puzzle is checked both in `canister_inspect_message` as well as in the actual `register` method call. Ideally, the `register` method never traps if `canister_inspect_message` wouldn‚Äôt trap as well, so that the canister can remember seeing a certain nonce.

NOTE: Even with that provision the same nonce can be used to ingress multiple messages, as `canister_inspect_message` is always run on a slightly old state. This cannot be avoided, but at least of these calls at most one can actually create a new user account.

=== Initialization

Each backend canister owns a range of user number. This range is set, by the index canister, during code installation, using the following Candid-encoded init argument:

....
type InternetIdentityInit = record {
  // Half-closed interval of user numbers assigned to this canister, [ left_bound, right_bound )
  assigned_user_number_range: record { nat64; nat64; };
};
....

=== Approach to upgrades

We don't need any logic recovery logic in pre/post-upgrade hooks because we place all user data to stable memory in a way that can be accessed directly.
The signature map is simply dropped on upgrade, so users will have to re-request their delegations.

=== Logic for signature/certified variable caching


== The Internet Identity Service frontend

The Internet Identity Service frontend is the user-visible part of the Internet Identity Service, and where it all comes together. It communicates with

* the user
* its backend using the Candid interface described above
* the security devices, using the Web Authentication API
* its past and future self, via the browser storage
* client application frontends, via the OAUTH protocol

=== Storage used

The frontend only stores a single piece of local storage, namely the current
user number, if known under the key `user_number`.

=== Flows

The following flows are not prescriptive of the UI, e.g. ‚Äúthe frontend asks the user for X‚Äù may also mean that on the previous shown page, there is already a field for X.

The possible login sub flows are shared among entry points `/` and `/autorized`, and are thus described separately. At the end of a succesful login subflow:

* The frontend knows the `user_number` (also stored in local storage).
* The frontend knows the current list of backend canisters, and thus which canister the user‚Äôs record is on.
* the frontend has a temporary session key
* the frontend has a `device_identity` for the present security device
* the frontend has a `frontend_delegation` from the security device to the session key

All update calls to the Internet Identity Service Backend are made under the `device_identity` and are signed with the session key.

The steps marked with üëÜ are the steps where the user presses the security device.

=== Subflow: Login as returning user

1. The frontend notices that `user_number` is present in local storage.
2. The frontend offers the choices
   * Welcome <user number>. Do you want to log in?
   * Log in as a different user
3. User wants to log in
4. The frontend queries `backends()` on the index canister to obtain the mapping from user numbers to backend canisters.
5. The frontend uses `lookup()` on the backend canister to fetch the list of devices
6. The frontend creates a session key.
7. üëÜ The frontend creates a delegation from the security device key to the session key, and signs it with the security key, using any of the devices listed in the user account. It notes which device was actually used.
8
Let `device_identity` of type `WebAuthenicationIdentity` be the identity created from that, and let `frontend_delegation` be the signed delegation.
8. The frontend configures the agent to use the session key for all further update calls.
9. Login complete

=== Subflow: Login via initial registration

1. The frontend notices that no `user_number` is present in local storage.
2. The frontend offers the choices
   * Create new account
   * Log into existing account with existing device
   * Log into existing account with new device
3. The user chooses to create a new account
4. üëÜ The frontend asks the security device to create a new public key. Let `device_identity` of type `WebAuthenicationIdentity` be the identity created from that.
5. The frontend creates a session key.
6. üëÜ The frontend creates a delegation from the security device key to the session key, and signs it with the security key. Let `frontend_delegation` be that signed delegation.
7. The frontend configures the agent to use the session key for all further update calls.
8. The frontend asks the user for a device alias.
9. The frontend queries `backends()` on the index canister to obtain the mapping from user numbers to backend canisters.
10. The frontend uses `stats()` on the second-to last canister in the list, to see if that canister is full.
+
--
* If it is not full: The frontend calls `register()` on the second-to-last canister, and obtains the `user_number`. If `register()` fails with `canister_init` (rare race conditions with the previous check), continue with next bullet point.

* If it is full: The frontend calls `register()` on the last canister, and obtains the `user_number`. If `register()` fails with `canister_init` (failure of the index canister to scale out), show an error message
--
11. The frontend calls `register()`, and obtains the `user_number`.
12. It stores the `user_number` in local storage.
13. The frontend insistently tells the user to write down this number.
14. Login complete

=== Subflow: Login via existing device

1. The frontend notices that no `user_number` is present in local storage.
   (Or user said ‚Äúlog in as different user‚Äù in returning flow.)
2. The frontend offers the choices
   * Create new account
   * Log into existing account with existing device
   * Log into existing account with new device
3. The user selects ‚ÄúLog into existing account with existing device‚Äù
4. The frontend asks the user for their user number, and stores that in `user_number`.
5. Continue as in ‚ÄúSubflow: Login as returning user‚Äù

=== Subflow: Login via new device

1. The frontend notices that no `user_number` is present in local storage.
2. The frontend offers the choices
   * Create new account
   * Log into existing account with existing device
   * Log into existing account with new device
3. The user selects ‚ÄúLog into existing account with new device‚Äù
4. The frontend asks the user for their user number, and stores that in `user_number`.
5. üëÜ Frontend asks security device for a new public key and credential id.
6. The frontend generates a link to be opened on another device where an existing authentication device exists.
+
--
The link format is:

  https://identity.ic0.app/#add_device=<userNumber>;<publicKey>[;<credentialId>]

where

- `userNumber` is the user number, as a decimal number
- `publicKey` is the hex-encoded DER-encoded WebAuth public key
- `credentialId`, if present, is the hex-encoded credential id required for this key

(See ‚ÄúFlow: adding devices via link‚Äù for what happens on the other device.)
--
7. The frontend polls the `lookup` query function until it sees that its `publicKey` has been added.
8. The frontend (maybe) gives an indication that the login was successful.
9. Login complete

=== Flow: Direct access to the frontend

This flow is the boring default

1. User browses to `https://identity.ic0.app/`
2. üëÜ The appropriate login subflow happens
3. User sees their management screen. In particular
+
- Their user number
- The list of their devices, with device aliases, and a button to remove
- A ‚Äúlogout‚Äù button

(One could imagine additional information, such last time a device was used, or even a list of recent client applications that the user logged into.)

=== Flow: adding devices via link

1. The user accesses `/#add_device=‚Ä¶`
2. üëÜ The appropriate login subflow happens
3. The user is asked if they really want to add this device, and under what name. This interaction needs to be clear enough so that a user who inadvertently clicked on an maliciously hidden `add_device` link will not continue.
4. Call `add()` to add new device
5. The hash fragment is removed from the URL
6. The user is told that they can go back to their other device.
+
(This could include a button to go to the management screen, or maybe this _is_ the management screen with a info box.)

=== Flow: OAUTH

1. The user accesses `/authorize` with oauth parameters
2. üëÜ The appropriate login subflow happens
3. The user is asked if they want to log into the client application, showing the client application frontend‚Äôs hostname.
4. The frontend calls `prepare_delegation()` with the client application frontend hostname and client application provided session key.
5. The frontend queries `get_delegation()` to get the delegation data
6. It converts it into the format of the `accessToken` and redirects the user back to the relaying party, as required by the oauth protocol

=== Flow: Deleting devices

1. The user is logged in, on the management view, and selects a device to delete.
2. If this is the device the user is currently logged in (the current `device_identity`), the user is warned.
3. If this is the last device of the user, the user is warned even more sternly.
4. The device is removed via `remove()`.
5. If this was the device that the user has logged in with, log out (as per ‚ÄúFlow: logging out‚Äù)
6. Else, refresh the device view.

=== Flow: Logging out

1. The user is logged in, on the management view, and clicks the logout button.
2. The `user_number` is removed from local storage
3. The page is reloaded (to send the user back to the beginning of ‚ÄúFlow: Direct access‚Äù).

== Deployment

=== Integration with bootstrap of NNS

A Internet Identity canister is created as an empty canister (i.e. no wasm module installed) during NNS bootstrap and its controller is set to the root canister. This is necessary to ensure that we can install/upgrade it later via a NNS proposal, and still get a reliable canister id.

This prepared canister is used for the stateless canister serving the Internet Identity frontend.

The index canister is created via proposal to the NNS; then its canister id becomes known and can be embedded in the frontend. The backend canisters are created by the index canister.

CAUTION: TODO The following instructions have not been updated with regard to scaling.

=== Initial installation

In a checkout of this repository, run:
[source,bash]
----
npm install
dfx build --network messaging idp_service
----

Note: This prepares the wasm module for installation on `messaging` testnet. If we want to deploy to beta, then we need to add a profile for it and use that instead.

Make note of the hash of wasm module:
[source,bash]
----
shasum -a 256 target/wasm32-unknown-unknown/release/idp_service.wasm
----

Download `ic-admin` for your platform from https://blobules.dfinity.systems/dfinity-ci-build.dfinity/ic-admin/0.1.0/[blobules]. If you are on macOS you will likely need to right-click on `ic-admin` and then select `Open` (to avoid having it considered malware).

Alternatively, you can build it from source. In a checkout of `dfinity`, run:
[source,bash]
----
cd rs
nix-shell
cargo build --bin ic-admin
----

Next, you will need `didc` to be able to produce the binary encoded Candid argument needed for installation. Either download it from https://github.com/dfinity/candid/releases/[the latest candid release] or build it from source.

The canister accepts a range of user ids that it's responsible for in `canister_init`. Currently, we only use one canister, so we don't really need to set a range. However, we still need to pass in some value to satisfy the interface. Run the following to get a file with the binary encoded value needed:
[source,bash]
----
didc encode '(null)' | xxd -r -p > arg.in
----

Submit the proposal to install the canister on `messaging`:
[source,bash]
----
ic-admin --nns-url http://dcs-messaging-13.dfinity.systems:8080/ propose-to-change-nns-canister --test-neuron-proposer --canister-id rdmx6-jaaaa-aaaaa-aaadq-cai --mode install --wasm-module-path ~/work/idp-service/target/wasm32-unknown-unknown/release/idp_service.wasm --arg arg.in
----

The above will need to be adjusted to submit a proposal on the beta network (specifically the NNS url and we need to use a real neuron ID as the proposer instead of the test-neuron-proposer).

You can check http://dcs-messaging-13.dfinity.systems:8080/_/dashboard[messaging's dashboard] to confirm the hash of the wasm installed on the canister matches the one you took note of in the previous steps.

=== Upgrades of the canister

Similar to the steps during initial installation. The main difference is that you need to pass in a different mode to `ic-admin`. Run:
[source,bash]
----
ic-admin --nns-url http://dcs-messaging-13.dfinity.systems:8080/ propose-to-change-nns-canister --test-neuron-proposer --canister-id rdmx      6-jaaaa-aaaaa-aaadq-cai --mode upgrade --wasm-module-path ~/work/idp-service/target/wasm32-unknown-unknown/release/idp_service.wasm
----
