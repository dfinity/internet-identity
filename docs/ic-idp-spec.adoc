= The Internet Identity Specification
:toc2:
:toclevel: 4
:sectanchors:

== Introduction

This document describes and specifies the Internet Identity from various angles and at various levels of abstraction, namely:

 * High level goals, requirements and use cases
 * Overview of the security and identity machinery, including the interplay of identities, keys, and delegations
 * Interface as used by client applications frontends, i.e., the OAUTH-based spec
 * The interface of the Internet Identity Service _backend_, i.e., describing its contract at the Candid layer, as used by its frontend
 * Important implementation notes about the Internet Identity Service backend
 * Internal implementation notes about the Internet Identity Service frontend
 * Notes about deployment

The Internet Identity Service consists of

 * the backend, a canister on the IC. More precisely, a canister on the NNS subnet with a _well-known_ canister id, and
 * its frontend, a web application served by the backend canister.

Similarly, the client applications consist of a frontend (served by a canister) and (typically) one or more backend canisters. Only the frontend interacts with the Interenet Identity Service directly (via the OAUTH protocol described below).

== Goals, requirements and use cases

The Internet Identity service allows users to

 * maintain identities on the Internet Computer
 * log into these identities using one out of a set of security devices
 * manage this set of security devices

Some functional requirements are

 * users have separate identities per client application (more precisely, per client application frontend "hostname")
 * these identities are stable, i.e., do not depend on a user's security devices
 * the client frontends interact with any canister on the Internet Computer under the user‚Äôs identity with that frontend
 * users do not need ever to remember secret information (but possibly per-user non-secret information)
 * the security device does not need to be manually touched upon every interaction with a client application; a login is valid for a certain amount of time per identity

Some security requirements are

* The separate identities of a single user cannot be related merely based on their public key or principal ids, to impede user tracking.
* (many more, of course; apply common sense)

Some noteworthy security assumptions are:

* The delivery of frontend applications is secure. In particular, a user accessing the Internet Identity Service Frontend through a TLS-secured HTTP connection cannot be tricked into running another web application.

* The security devices only allow the use of their keys from the same web application that created the key (in our case, the Internet Identity Service Frontend).

* The Internet Identity Service backend can keep a secret.
+
(This assumption is only used relied on for the privacy aspect.)


== Identity design and data model

A single canister with a well-known canister id (the _Internet Identity Canister ID_, in the following `ii_canister_id`) controls all users' identities.

The Internet Computer serves this frontend under hostname `https://identity.ic0.app`.

The canister maintains a secret salt (in the following the `salt`), a 32 byte long blob that is obtained via the Internet Computer‚Äôs source of secure randomness.

A user account is identified by a unique _user number_, a smallish natural number chosen by the canister.

A client application frontend is identified by its hostname (e.g., `abcde-efg.ic0.app`, `nice-name.ic0.app`, `non-ic-application.com`). Frontend application can be served by canisters or by websites that are not hosted on the Internet
Computer.

A user has a separate _user identity_ for each client application frontend (i.e., per hostname). This identity is a https://docs.dfinity.systems/public/#id-classes[_self-authenticating id_] that is derived from a https://hydra.dfinity.systems/latest/dfinity-ci-build/ic-ref.pr-319/interface-spec/1/index.html#canister-signatures[canister signature] public ‚Äúkey‚Äù based on the `ii_canister_id` and a seed of the form
....
H(|salt| ¬∑ salt ¬∑ |user_number| ¬∑ user_number ¬∑ |frontend_host| ¬∑ frontend_host)
....
where `H` is SHA-256, `¬∑` is concatenation, `|‚Ä¶|` is the length of `‚Ä¶` in bytes, `user_number` is the ASCII-encoding of the user number as a decimal number and `frontend_host` is the ASCII-encoding of the client application frontend‚Äôs hostname.

The Internet Identity Service Backend stores the following data in user accounts, indexed by the respective user number:

* a set of _device information_, consisting of
- the device‚Äôs public key (DER-encoded)
- a device _alias_, chosen by the user to recognize the device
- an optional _credential id_, which is necessary for WebAuthN authentication

(Comment Jan: the following three paragraphs require more explanation)
When a client application frontend wants to log in as a user, it uses a _session key_ (e.g., Ed25519 or ECDSA), and by way of the OAUTH protocol (details below) obtains a https://docs.dfinity.systems/public/#authentication[_delegation chain_] that allows the session key to sign for the user‚Äôs main identity.

The delegation chain consits of one delegation, called the _client delegation_. It delegates from the user identity (for the given client application frontend) to the session key. This delegation is created by the Internet Identity Service Canister, and signed using a https://hydra.dfinity.systems/latest/dfinity-ci-build/ic-ref.pr-319/interface-spec/1/index.html#canister-signatures[canister signature]. This delegation is unscoped (valid for all canisters) and has a lifetime of *TODO*.

The Internet Identity Service Frontend also manages a _identity frontend delegation_, delegating from the security device‚Äôs public key to a session key managed by this frontend, so that it can interact with the backend without having to invoke the security device for each signature.

[#oauth]
== OAUTH protocol

This section describes the Internet Identity Service from the point of view of a client appliation frontend (a.k.a. the relaying party).

The client application frontend creates a session key pair (e.g., Ed25519). It then redirects the user to the Internet Identity Service Canister frontend, more concretely to the URL

  https://identity.ic0.app/authorize?‚Ä¶

with URL parameters as specified by the OAUTH protocol. Of particular interest is the parameter

* the `login_hint` parameter contains the public key of the session key created by the client application frontend, as a hex-encoded DER key.

* the `redirect_uri`, the hostname of which is used to identify the client application frontend‚Äôs hostname.

If the Internet Identity Service Frontend can authorize this request, the url parameters on the callback (i.e., the provided `redirect_uri`) contain in particular

* the `accessToken`, which is the hex-encoding of a JSON encoding of the delegation chain in the following format
+
....
{
  delegations: [
    { delegation: {
        expiration: (hex-encoded big-endian expiration date)
        pubkey: (hex-encoded DER-encoded public key of delegatee)
        targets: (optional)
          [ (hex-encoded binary canister id)
            ‚Ä¶
          ]
      },
      signature: (hex-encoded signature)
    }
    ‚Ä¶
  ],
  publicKey: (hex-encoded public key underlying the user identity))
}
....
+
This structure can be converted by the client application into a CBOR-encoded delegation chain as used for https://docs.dfinity.systems/public/#authentication[_authentication on the IC_].

The client application frontend needs to be able to detect when any of the delegations in the chain has expired, and re-authorize the user in that case.

The https://www.npmjs.com/package/@dfinity/authentication[`@dfinity/authetication` NPM package] provides functionality for this workflow.

The client application frontend should support delegation chains of lenght more than one, and delegations with `targets`, even if the present version of this spec does not use them, to be compatible with possible future versions.

== The Internet Identity Service Backend interface

This section describes the interface that the backend canister provides.

This interface is currently only used by its own frontend. This tight coupling means that this interface may change, even in incompatible ways. We therefore do not have to apply Candid best practices for backward-compatibility (such as using records for arguments and results).

The summary is given by the following Candid interface (exluding the methods required for the https://www.notion.so/Design-HTTP-Requests-to-Canisters-d6bc980830a947a88bf9148a25169613[HTTP Gateway interface]):
....
type UserNumber = nat64;
type PublicKey = blob;
type CredentialId = blob;
type DeviceAlias = text;
type DeviceKey = PublicKey;
type UserKey = PublicKey;
type SessionKey = PublicKey;
type FrontendHostname = text;
type Timestamp = nat64;

type DeviceData = record {
  pubkey : DeviceKey;
  alias : text;
  credential_id : opt CredentialId;
};

type Delegation = record {
  pubkey: SessionKey;
  expiration: Timestamp;
  targets: opt vec principal;
};
type SignedDelegation = record {
  delegation: Delegation;
  signature: blob;
};
type GetDelegationResponse = variant {
  signed_delegation: SignedDelegation;
  no_such_delegation;
};

service : {
  register : (DeviceData) -> (UserNumber);
  add : (UserNumber, DeviceData) -> ();
  remove : (UserNumber, DeviceKey) -> ();
  lookup : (UserNumber) -> (vec DeviceData) query;

  prepare_delegation : (UserNumber, FrontendHostname, SessionKey) -> (UserKey, Timestamp);
  get_delegation: (UserNumber, FrontendHostname, SessionKey, Timestamp) -> (GetDelegationResponse) query;
}
....

=== The `register` method

The `register` method is used to create a new user. The Internet Identity Service backend creates a _fresh_ user number, creates the account record, and adds the given device as the first device.

*Authorization*: This request must be sent to the canister with `caller` that is the self-authenticating id derived from the given `DeviceKey`.

WARNING: *TODO*: This method will be protected by some form of proof of work or captcha, which needs involvement from the canister.

=== The `add` method

The `add` method appends a new device to the given user‚Äôs record.

The Internet Identity Service backend rejects the call if the user already has a device on record with the given public key.

This may also fail (with a _reject_) if the user is registering too many devices.

*Authorization*: This request must be sent to the canister with `caller` that is the self-authenticating id derived from any of the public keys of devices associated with the user before this call.

=== The `remove` method

The `remove` method removes a device, identified by its public key, from the list of devices a user has.

It is allowed to remove the key that is used to sign this request. This can be useful for a panic button functionality.

It is allowed to remove the last key, to completely disable a user. The canister may forget that user completely then, assuming the user number generation algorithm prevents new users from getting the same user number.

It is the responsibility of the frontend UI to protect the user from doing these things accidentally.

*Authorization*: This request must be sent to the canister with `caller` that is the self-authenticating id derived from any of the public keys of devices associated with the user before this call.

=== The `lookup` query method

Fetches all data associated with a user.

*Authorization*: Anyone can call this

=== The `prepare_delegation` method

The `prepare_delegation` method causes the Internet Identity Service backend to prepare a delegation from the user identity associated with the given user number and Client Application Frontend Hostname to the given session key.

This method returns the user‚Äôs identity that‚Äôs associated with the given Client Application Frontend Hostname. By returning this here, and not in the less secure `get_delegation` query, we prevent attacks that trick the user into using a wrong identity.

The method returns the expiration timestamp of the delegation. This is returned purely so that the client can feed it back to the backend in `get_delegation`.

The actual delegation can be fetched using `get_delegation` immediately afterwards.

*Authorization*: This request must be sent to the canister with `caller` that is the self-authenticating id derived from any of the public keys of devices associated with the user before this call.


=== The `get_delegation` query method

For a certain amount of time after a call to `prepare_delegation`, a query call to `get_delegation` with the same arguments, plus the timestamp returned from `prepare_delegation`, actually fetches the delegation.

Together with the `UserKey` returned by `prepare_delegation`, the result of this method is used by the Frontend to form the `accessToken` in the <<oauth,OAUTH flow>>.

*Authorization*: Anyone can call this

== The Internet Identity Service backend internals

This section, which is to be expanded, describes interesting design choices about the internals of the Internet Identity Service Canister. In particular

=== Internal data model and data structures used

The primary data structure used by the backend is a map from user number to the list of user devices.
Device lists are stored directly in canister stable memory.
The total amount of storage for is limited to 510 bytes per user.
With the stable memory size of 4GiB we can store around 8 * 10^6 user records in a single canister.

==== Stable memory layout

All the integers (u64, u32, u16) are encoded in Little-Endian.
....
Storage ::= {
  Header
  UserRecords
}

Header ::= {
  magic : u8[3] = "IIC"
  version : u8 = 1
  number_of_user_records : u32
  user_number_range_lo : u64
  user_number_range_hi : u64
  entry_size: u16
  salt: u8[32]
  padding : u8[454]
}

UserRecords ::= UserRecord*

UserRecord ::= {
  size : u16
  candid_bytes: u8[510]
}
....

User record for user number N is stored at offset `sizeof(Header) + (N - user_number_range_lo) * sizeof(UserRecord)`.
Each record consists of a 16 bit `size` ‚àà [0..510] followed by `size` bytes of Candid-serialized list of devices.

....
type UserDeviceList = vec(record {
  pubkey : DeviceKey;
  alias : text;
  credential_id : opt CredentialId;
});
....

=== Initialization

The Internet Identity canister is designed for sharded deployments.
There can be many simulteniously installed instances of the canister code, each serving requests of a subset of users.
As users are identified by their user number, we split the range of user numbers into continuous non-overlapping half-closed intervals and assign each region to one canister instance.
The assigned range is passed to the canister as an init argument, encoded in Candid:

....
type InternetIdentityInit = record {
  // Half-closed interval of user numbers assigned to this canister, [ left_bound, right_bound )
  assigned_user_number_range: record { nat64; nat64; };
};
....

=== Approach to upgrades

We don't need any logic recovery logic in pre/post-upgrade hooks because we place all user data to stable memory in a way that can be accessed directly.
The signature map is simply dropped on upgrade, so users will have to re-request their delegations.

=== Logic for signature/certified variable caching


== The Internet Identity Service frontend

The Internet Identity Service frontend is the user-visible part of the Internet Identity Service, and where it all comes together. It communicates with

* the user
* its backend using the Candid interface described above
* the security devices, using the Web Authentication API
* its past and future self, via the browser storage
* client application frontends, via the OAUTH protocol

=== Storage used

The frontend only stores a single piece of local storage, namely the current
user number, if known under the key `user_number`.

=== Flows

The following flows are not prescriptive of the UI, e.g. ‚Äúthe frontend asks the user for X‚Äù may also mean that on the previous shown page, there is already a field for X.

The possible login sub flows are shared among entry points `/` and `/autorized`, and are thus described separately. At the end of a succesful login subflow:

* The frontend knows the `user_number` (also stored in local storage).
* the frontend has a temporary session key
* the frontend has a `device_identity` for the present security device
* the frontend has a `frontend_delegation` from the security device to the session key

All update calls to the Internet Identity Service Backend are made under the `device_identity` and are signed with the session key.

The steps marked with üëÜ are the steps where the user presses the security device.

=== Subflow: Login as returning user

1. The frontend notices that `user_number` is present in local storage.
2. The frontend offers the choices
   * Welcome <user number>. Do you want to log in?
   * Log in as a different user
3. User wants to log in
4. The frontend uses `lookup` to fetch the list of devices
5. The frontend creates a session key.
6. üëÜ The frontend creates a delegation from the security device key to the session key, and signs it with the security key, using any of the devices listed in the user account. It notes which device was actually used.
+
Let `device_identity` of type `WebAuthenicationIdentity` be the identity created from that, and let `frontend_delegation` be the signed delegation.
7. The frontend configures the agent to use the session key for all further update calls.
8. Login complete

=== Subflow: Login via initial registration

1. The frontend notices that no `user_number` is present in local storage.
2. The frontend offers the choices
   * Create new account
   * Log into existing account with existing device
   * Log into existing account with new device
3. The user chooses to create a new account
4. üëÜ The frontend asks the security device to create a new public key. Let `device_identity` of type `WebAuthenicationIdentity` be the identity created from that.
5. The frontend creates a session key.
6. üëÜ The frontend creates a delegation from the security device key to the session key, and signs it with the security key. Let `frontend_delegation` be that signed delegation.
7. The frontend configures the agent to use the session key for all further update calls.
8. The frontend asks the user for a device alias.
9. The frontend calls `register()`, and obtains the `user_number`.
10. It stores the `user_number` in local storage.
11. The frontend insistently tells the user to write down this number.
12. Login complete

=== Subflow: Login via existing device

1. The frontend notices that no `user_number` is present in local storage.
   (Or user said ‚Äúlog in as different user‚Äù in returning flow.)
2. The frontend offers the choices
   * Create new account
   * Log into existing account with existing device
   * Log into existing account with new device
3. The user selects ‚ÄúLog into existing account with existing device‚Äù
4. The frontend asks the user for their user number, and stores that in `user_number`.
5. Continue as in ‚ÄúSubflow: Login as returning user‚Äù

=== Subflow: Login via new device

1. The frontend notices that no `user_number` is present in local storage.
2. The frontend offers the choices
   * Create new account
   * Log into existing account with existing device
   * Log into existing account with new device
3. The user selects ‚ÄúLog into existing account with new device‚Äù
4. The frontend asks the user for their user number, and stores that in `user_number`.
5. üëÜ Frontend asks security device for a new public key and credential id.
6. The frontend generates a link to be opened on another device where an existing authentication device exists.
+
--
The link format is:

  https://identity.ic0.app/#add_device=<userNumber>;<publicKey>[;<credentialId>]

where

- `userNumber` is the user number, as a decimal number
- `publicKey` is the hex-encoded DER-encoded WebAuth public key
- `credentialId`, if present, is the hex-encoded credential id required for this key

(See ‚ÄúFlow: adding devices via link‚Äù for what happens on the other device.)
--
7. The frontend polls the `lookup` query function until it sees that its `publicKey` has been added.
8. The frontend (maybe) gives an indication that the login was successful.
9. Login complete

=== Flow: Direct access to the frontend

This flow is the boring default

1. User browses to `https://identity.ic0.app/`
2. üëÜ The appropriate login subflow happens
3. User sees their management screen. In particular
+
- Their user number
- The list of their devices, with device aliases, and a button to remove
- A ‚Äúlogout‚Äù button

(One could imagine additional information, such last time a device was used, or even a list of recent client applications that the user logged into.)

=== Flow: adding devices via link

1. The user accesses `/#add_device=‚Ä¶`
2. üëÜ The appropriate login subflow happens
3. The user is asked if they really want to add this device, and under what name. This interaction needs to be clear enough so that a user who inadvertently clicked on an maliciously hidden `add_device` link will not continue.
4. Call `add()` to add new device
5. The hash fragment is removed from the URL
6. The user is told that they can go back to their other device.
+
(This could include a button to go to the management screen, or maybe this _is_ the management screen with a info box.)

=== Flow: OAUTH

1. The user accesses `/authorize` with oauth parameters
2. üëÜ The appropriate login subflow happens
3. The user is asked if they want to log into the client application, showing the client application frontend‚Äôs hostname.
4. The frontend calls `prepare_delegation()` with the client application frontend hostname and client application provided session key.
5. The frontend queries `get_delegation()` to get the delegation data
6. It converts it into the format of the `accessToken` and redirects the user back to the relaying party, as required by the oauth protocol

=== Flow: Deleting devices

1. The user is logged in, on the management view, and selects a device to delete.
2. If this is the device the user is currently logged in (the current `device_identity`), the user is warned.
3. If this is the last device of the user, the user is warned even more sternly.
4. The device is removed via `remove()`.
5. If this was the device that the user has logged in with, log out (as per ‚ÄúFlow: logging out‚Äù)
6. Else, refresh the device view.

=== Flow: Logging out

1. The user is logged in, on the management view, and clicks the logout button.
2. The `user_number` is removed from local storage
3. The page is reloaded (to send the user back to the beginning of ‚ÄúFlow: Direct access‚Äù).

== Deployment

This section needs to describe aspects like

* why and how the frontend is bundled with and served by the canister itself.
* how the Internet Identity Service canister id stays predictable and well-known

=== Integration with bootstrap of NNS

The Internet Identity canister is created as an empty canister (i.e. no wasm module installed) during NNS bootstrap and its controller is set to the root canister. This is necessary to ensure that we can install/upgrade it later via a NNS proposal.

=== Initial installation

In a checkout of this repository, run:
[source,bash]
----
npm install
dfx build idp_service
----

Make note of the hash of wasm module:
[source,bash]
----
shasum -a 256 target/wasm32-unknown-unknown/release/idp_service.wasm
----

Download `ic-admin` for your platform from https://blobules.dfinity.systems/dfinity-ci-build.dfinity/ic-admin/0.1.0/[blobules]. If you are on macOS you will likely need to right-click on `ic-admin` and then select `Open` (to avoid having it considered malware).

Alternatively, you can build it from source. In a checkout of `dfinity`, run:
[source,bash]
----
cd rs
nix-shell
cargo build --bin ic-admin
----

Next, you will need `didc` to be able to produce the binary encoded Candid argument needed for installation. Either download it from https://github.com/dfinity/candid/releases/[the latest candid release] or build it from source.

The canister accepts a range of user ids that it's responsible for in `canister_init`. Currently, we only use one canister, so we don't really need to set a range. However, we still need to pass in some value to satisfy the interface. Run the following to get a file with the binary encoded value needed:
[source,bash]
----
didc encode '(null)' | xxd -r -p > arg.in
----

Submit the proposal to install the canister on `messaging`:
[source,bash]
----
ic-admin --nns-url http://dcs-messaging-13.dfinity.systems:8080/ propose-to-change-nns-canister --test-neuron-proposer --canister-id rdmx6-jaaaa-aaaaa-aaadq-cai --mode install --wasm-module-path ~/work/idp-service/target/wasm32-unknown-unknown/release/idp_service.wasm --arg arg.in
----

The above will need to be adjusted to submit a proposal on the beta network (specifically the NNS url and we need to use a real neuron ID as the proposer instead of the test-neuron-proposer).

You can check http://dcs-messaging-13.dfinity.systems:8080/_/dashboard[messaging's dashboard] to confirm the hash of the wasm installed on the canister matches the one you took note of in the previous steps.

=== Upgrades of the canister

Similar to the steps during initial installation. The main difference is that you need to pass in a different mode to `ic-admin`. Run:
[source,bash]
----
ic-admin --nns-url http://dcs-messaging-13.dfinity.systems:8080/ propose-to-change-nns-canister --test-neuron-proposer --canister-id rdmx      6-jaaaa-aaaaa-aaadq-cai --mode upgrade --wasm-module-path ~/work/idp-service/target/wasm32-unknown-unknown/release/idp_service.wasm
----
