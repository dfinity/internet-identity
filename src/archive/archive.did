type HeaderField = record { text; text; };

type HttpRequest = record {
  method: text;
  url: text;
  headers: vec HeaderField;
  body: blob;
};

type HttpResponse = record {
  status_code: nat16;
  headers: vec HeaderField;
  body: blob;
  upgrade : opt bool;
  streaming_strategy: opt StreamingStrategy;
};

type StreamingCallbackHttpResponse = record {
  body: blob;
  token: opt Token;
};

type Token = record {};

type StreamingStrategy = variant {
  Callback: record {
    callback: func (Token) -> (StreamingCallbackHttpResponse) query;
    token: Token;
  };
};

type Timestamp = nat64;
type UserNumber = nat64;
type CredentialId = blob;
type PublicKey = blob;
type DeviceKey = PublicKey;

type Purpose = variant {
    recovery;
    authentication;
};

type KeyType = variant {
    unknown;
    platform;
    cross_platform;
    seed_phrase;
};

type DeviceProtection = variant {
    protected;
    unprotected;
};

type OperationType = variant {
    register_anchor: record {
        initial_device: DeviceDataWithoutAlias;
    };
    add_device: record {
        new_device: DeviceDataWithoutAlias;
    };
    update_device: record {
        updated_device: PublicKey;
        changed_data: DeviceDataUpdate;
    };
    remove_device: record {
        removed_device: PublicKey;
    };
};

type LogEntry = record {
    user_number: UserNumber;
    operation: OperationType;
    timestamp: Timestamp;
    caller: principal;
    sequence_number: nat64;
};

type DeviceDataWithoutAlias = record {
    pubkey: DeviceKey;
    credential_id: opt  CredentialId;
    purpose: Purpose;
    key_type: KeyType;
    protection: DeviceProtection;
};

type DeviceDataUpdate = record {
    alias: opt Hidden;
    credential_id: opt CredentialId;
    purpose: opt Purpose;
    key_type: opt KeyType;
    protection: opt DeviceProtection;
};

// Placeholder for information that has been hidden for privacy reasons.
type Hidden = variant {
    hidden_for_privacy_reasons;
};

type Cursor = variant {
    timestamp: Timestamp; // get logs starting from this Timestamp
    next_token: blob; // submit previously received token to fetch the next page of log entries
};

type UserLogs = record {
  entries: vec opt LogEntry;
  next_token: opt blob // cursor to fetch the next page of log entries (if any)
};

type Logs = record {
  entries: vec opt LogEntry;
  next_idx: opt nat64 // next index to fetch the next page of log entries (if any)
};

type ArchiveInit = record {
  ii_canister: principal;
};

service : (opt ArchiveInit) -> {

  // Returns the logs for the given user number. If a timestamp is given, only the logs starting from that timestamp are
  // returned. Use the Cursor to skip to later log entries.
  // This function can be called anonymously.
  //
  // Parameters:
  // 1. user number to fetch the logs for
  // 2. optional cursor to specify which logs to fetch
  // 3. optional limit of the number of entries. If no limit is given, at most 1000 entries are returned.
  get_user_logs : (UserNumber, opt Cursor, opt nat16) -> (UserLogs) query;

  // Returns the latest up to 1000 log entries. If an index is given, entries starting from the given index are returned.
  //
  // Parameters:
  // 1. optional index into the list of log entries
  // 2. optional limit of the number of entries. If no limit is given, at most 1000 entries are returned.
  get_logs : (opt nat64, opt nat16) -> (Logs) query;

  // Writes a log entry. Only the Internet Identity canister is authorized to call this function.
  write_entry : (UserNumber, Timestamp, blob) -> ();

  // HTTP endpoint to expose metrics for Prometheus.
  http_request: (request: HttpRequest) -> (HttpResponse) query;
}
