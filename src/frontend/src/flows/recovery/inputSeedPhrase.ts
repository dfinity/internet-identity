import { html, nothing, render, TemplateResult } from "lit-html";
import {
  Warning,
  RECOVERYPHRASE_WORDCOUNT,
  dropLeadingUserNumber,
  getWarnings,
} from "../../crypto/mnemonic";
import { warningIcon } from "../../components/icons";
import { questions } from "../faq/questions";

const pageContent = () => html`
  <style>
    #inputSeedPhrase {
      width: 100%;
      height: 6rem;
      box-sizing: border-box;
      margin-bottom: 1rem;
      font-size: 1rem;
      font-weight: 400;
    }

    .full-width {
      width: 100%;
    }

    .warningBox {
      margin-top: 0.5rem;
      margin-bottom: 0.5rem;
    }
  </style>
  <div class="container full-width">
    <h1>Your seed phrase</h1>
    <p>Please provide your seed phrase</p>
    <textarea id="inputSeedPhrase" placeholder="Your seed phrase"></textarea>
    <div id="warnings"></div>
    <button id="inputSeedPhraseContinue" class="primary">Continue</button>
    <button id="inputSeedPhraseCancel">Cancel</button>
  </div>
`;

export const inputSeedPhrase = async (
  userNumber: bigint
): Promise<string | null> => {
  const container = document.getElementById("pageContent") as HTMLElement;
  render(pageContent(), container);
  return init(userNumber);
};

const init = (userNumber: bigint): Promise<string | null> =>
  new Promise((resolve) => {
    const inputSeedPhraseInput = document.getElementById(
      "inputSeedPhrase"
    ) as HTMLInputElement;

    // Look up the warningsDiv element early; this must not be done inside in the warnings
    // generation callback since -- due to debouncing -- it may be called after some period of
    // time and the user may have left the page; we may effectively pick up the wrong element.
    const warningsDiv = document.getElementById("warnings") as HTMLDivElement;

    // Debounce the warning generation as not to spam the user
    let handle: number;
    const debouncedWarnings = () => {
      clearTimeout(handle);
      handle = window.setTimeout(() => {
        warningsDiv.innerHTML = ""; // Clear previously generated warnings

        // Actually generate the warnings
        for (const warning of getWarningMessages(
          userNumber,
          inputSeedPhraseInput.value.trim()
        )) {
          const div = document.createElement("div");
          render(mkWarningDiv(warning), div);
          warningsDiv.appendChild(div);
        }
      }, 500);
    };

    inputSeedPhraseInput.oninput = () => {
      debouncedWarnings();
    };
    const inputSeedPhraseContinue = document.getElementById(
      "inputSeedPhraseContinue"
    ) as HTMLButtonElement;
    const inputSeedPhraseCancel = document.getElementById(
      "inputSeedPhraseCancel"
    ) as HTMLButtonElement;
    inputSeedPhraseCancel.onclick = () => {
      resolve(null);
    };
    inputSeedPhraseContinue.onclick = async () => {
      const inputValue = dropLeadingUserNumber(
        inputSeedPhraseInput.value.trim()
      );
      resolve(inputValue);
    };
  });

export const getWarningMessages = (
  userNumber: bigint,
  input: string
): (TemplateResult | string)[] => {
  return getWarnings(userNumber, input).map((warning) =>
    warningMessage(userNumber, warning)
  );
};

/** The warning messages, for each warning type. */
export const warningMessage = (
  userNumber: bigint,
  warning: Warning
): TemplateResult | string => {
  switch (warning.type) {
    case "bad_chars": {
      return html`Unexpected character${warning.chars.length > 1 ? "s" : ""}:
      ${warning.chars.map((c, i) => [
        html`<code>${c === "\n" ? "newline" : c === "\t" ? "tab" : c}</code>`,
        i < warning.chars.length - 1 ? ", " : nothing,
      ])}`;
    }

    case "repeated_whitespace": {
      return html`Multiple
      whitespaces${warning.between
        ? html` between <code>${warning.between[0]}</code> and
            <code>${warning.between[1]}</code>`
        : ""}`;
    }

    case "bad_anchor": {
      return html`Recovering anchor <strong>${userNumber}</strong>, but recovery
        phrase suggests anchor <strong>${warning.anchor}</strong>`;
    }

    case "bad_word_count": {
      return `Recovery phrase should contain ${RECOVERYPHRASE_WORDCOUNT} words, but input contains ${warning.count} words.`;
    }

    case "bad_words": {
      return html`Unexpected word${warning.words.length > 1 ? "s" : ""}:
      ${warning.words.map((word, i) => [
        html`<code>${word}</code>`,
        i < warning.words.length - 1 ? ", " : nothing,
      ])}`;
    }

    case "invalid": {
      return html`
        This does not look like a seed phrase generated by Internet Identity,
        please make sure to copy the full seedphrase and try again. For more
        information, please see
        <a href="/faq#${questions.invalidSeedphrase.anchor}"
          >${questions.invalidSeedphrase.question}</a
        >
      `;
    }
  }
};

const mkWarningDiv = (warningMessage: string | TemplateResult) => html`
    <div class="warningBox">
      <span class="warningIcon">${warningIcon}</span>
      <div class="warningMessage">
        <p>${warningMessage}</p>
      </div class="warningMessage">
    </div>`;
