type UserNumber = nat64;
type PublicKey = blob;
type CredentialId = blob;
type DeviceKey = PublicKey;
type UserKey = PublicKey;
type SessionKey = PublicKey;
type FrontendHostname = text;
type Timestamp = nat64;

type HeaderField = record {
    name: text;
    value: text;
};

type HttpRequest = record {
    method: text;
    url: text;
    headers: vec HeaderField;
    body: blob;
    certificate_version: opt nat16;
};

type HttpResponse = record {
    status_code: nat16;
    headers: vec HeaderField;
    body: blob;
    upgrade: opt bool;
    streaming_strategy: opt StreamingStrategy;
};

type StreamingCallbackHttpResponse = record {
    body: blob;
    token: opt Token;
};

type Token = record {};

type StreamingStrategy = variant {
    Callback: record {
        callback: func (Token) -> (StreamingCallbackHttpResponse) query;
        token: Token;
    };
};

type Purpose = variant {
    recovery: null;
    authentication: null;
};

type KeyType = variant {
    unknown: null;
    platform: null;
    cross_platform: null;
    seed_phrase: null;
    browser_storage_key: null;
};

type DeviceProtection = variant {
    protected: null;
    unprotected: null;
};

type Challenge = record {
    png_base64: text;
    challenge_key: ChallengeKey;
};

type DeviceData = record {
    pubkey: DeviceKey;
    alias: text;
    credential_id: opt CredentialId;
    purpose: Purpose;
    key_type: KeyType;
    protection: DeviceProtection;
    origin: opt text;
    metadata: opt MetadataMap;
};

type DeviceWithUsage = record {
    pubkey: DeviceKey;
    alias: text;
    credential_id: opt CredentialId;
    purpose: Purpose;
    key_type: KeyType;
    protection: DeviceProtection;
    origin: opt text;
    last_usage: opt Timestamp;
    metadata: opt MetadataMap;
};

type MetadataMap = vec record {
    key: text;
    value: variant {
        map: MetadataMap;
        string: text;
        bytes: vec nat8;
    };
};

type RegisterResponse = variant {
    registered: record {
        user_number: UserNumber;
    };
    canister_full: null;
    bad_challenge: null;
};

type AddTentativeDeviceResponse = variant {
    added_tentatively: record {
        verification_code: text;
        device_registration_timeout: Timestamp;
    };
    device_registration_mode_off: null;
    another_device_tentatively_added: null;
};

type VerifyTentativeDeviceResponse = variant {
    verified: null;
    wrong_code: record {
        retries_left: nat8;
    };
    device_registration_mode_off: null;
    no_device_to_verify: null;
};

type Delegation = record {
    pubkey: PublicKey;
    expiration: Timestamp;
    targets: opt vec principal;
};

type SignedDelegation = record {
    delegation: Delegation;
    signature: blob;
};

type GetDelegationResponse = variant {
    signed_delegation: SignedDelegation;
    no_such_delegation: null;
};

type InternetIdentityStats = record {
    users_registered: nat64;
    storage_layout_version: nat8;
    assigned_user_number_range: record {
        start: nat64;
        end: nat64;
    };
    archive_info: ArchiveInfo;
    canister_creation_cycles_cost: nat64;
    max_num_latest_delegation_origins: nat64;
    latest_delegation_origins: vec FrontendHostname;
};

type ArchiveConfig = record {
    module_hash: blob;
    entries_buffer_limit: nat64;
    entries_fetch_limit: nat16;
    polling_interval_ns: nat64;
};

type ArchiveInfo = record {
    archive_canister: opt principal;
    archive_config: opt ArchiveConfig;
};

type RateLimitConfig = record {
    time_per_token_ns: nat64;
    max_tokens: nat64;
};

type InternetIdentityInit = record {
    assigned_user_number_range: opt record {
        start: nat64;
        end: nat64;
    };
    archive_config: opt ArchiveConfig;
    canister_creation_cycles_cost: opt nat64;
    register_rate_limit: opt RateLimitConfig;
    max_num_latest_delegation_origins: opt nat64;
    max_inflight_captchas: opt nat64;
};

type ChallengeKey = text;

type ChallengeResult = record {
    key: ChallengeKey;
    chars: vec text;
};

type DeviceRegistrationInfo = record {
    tentative_device: opt DeviceData;
    expiration: Timestamp;
};

type IdentityAnchorInfo = record {
    devices: vec DeviceWithUsage;
    device_registration: opt DeviceRegistrationInfo;
};

type AnchorCredentials = record {
    credentials: vec WebAuthnCredential;
    recovery_credentials: vec WebAuthnCredential;
    recovery_phrases: vec PublicKey;
};

type WebAuthnCredential = record {
    credential_id: CredentialId;
    pubkey: PublicKey;
};

type DeployArchiveResult = variant {
    success: record {
        principal: principal;
    };
    creation_in_progress: null;
    failed: text;
};

type BufferedArchiveEntry = record {
    anchor_number: UserNumber;
    timestamp: Timestamp;
    sequence_number: nat64;
    entry: blob;
};

type IdentityNumber = nat64;

type WebAuthn = record {
    credential_id: CredentialId;
    pubkey: PublicKey;
};

type PublicKeyAuthn = record {
    pubkey: PublicKey;
};

type AuthnMethod = variant {
    webauthn: WebAuthn;
    pubkey: PublicKeyAuthn;
};

type AuthnMethodProtection = variant {
    protected: null;
    unprotected: null;
};

type AuthnMethodData = record {
    authn_method: AuthnMethod;
    protection: AuthnMethodProtection;
    purpose: Purpose;
    metadata: MetadataMap;
    last_authentication: opt Timestamp;
};

type AuthnMethodRegistrationInfo = record {
    authn_method: opt AuthnMethodData;
    expiration: Timestamp;
};

type IdentityInfo = record {
    authn_methods: vec AuthnMethodData;
    authn_method_registration: opt AuthnMethodRegistrationInfo;
    metadata: MetadataMap;
};

type IdentityInfoResponse = variant {
    ok: IdentityInfo;
};

type AuthnMethodAddResponse = variant {
    ok: null;
    invalid_metadata: text;
};

type AuthnMethodRemoveResponse = variant {
    ok: null;
};

type IdentityMetadataReplaceResponse = variant {
    ok: null;
};

service : (opt InternetIdentityInit) -> {
    init_salt: () -> ();
    create_challenge : () -> (Challenge);
    register : (DeviceData, ChallengeResult, opt principal) -> (RegisterResponse);
    add : (UserNumber, DeviceData) -> ();
    update : (UserNumber, DeviceKey, DeviceData) -> ();
    replace : (UserNumber, DeviceKey, DeviceData) -> ();
    remove : (UserNumber, DeviceKey) -> ();
    lookup : (UserNumber) -> (vec DeviceData) query;
    get_anchor_credentials : (UserNumber) -> (AnchorCredentials) query;
    get_anchor_info : (UserNumber) -> (IdentityAnchorInfo);
    get_principal : (UserNumber, FrontendHostname) -> (principal) query;
    stats : () -> (InternetIdentityStats) query;

    enter_device_registration_mode : (UserNumber) -> (Timestamp);
    exit_device_registration_mode : (UserNumber) -> ();
    add_tentative_device : (UserNumber, DeviceData) -> (AddTentativeDeviceResponse);
    verify_tentative_device : (UserNumber, verification_code: text) -> (VerifyTentativeDeviceResponse);

    prepare_delegation : (UserNumber, FrontendHostname, SessionKey, maxTimeToLive : opt nat64) -> (UserKey, Timestamp);
    get_delegation: (UserNumber, FrontendHostname, SessionKey, Timestamp) -> (GetDelegationResponse) query;

    http_request: (request: HttpRequest) -> (HttpResponse) query;
    http_request_update: (request: HttpRequest) -> (HttpResponse);

    deploy_archive: (wasm: blob) -> (DeployArchiveResult);
    fetch_entries: () -> (vec BufferedArchiveEntry);
    acknowledge_entries: (sequence_number: nat64) -> ();

    identity_info: (IdentityNumber) -> (opt IdentityInfoResponse);
    identity_metadata_replace: (IdentityNumber, MetadataMap) -> (opt IdentityMetadataReplaceResponse);
    authn_method_add: (IdentityNumber, AuthnMethodData) -> (opt AuthnMethodAddResponse);
    authn_method_remove: (IdentityNumber, PublicKey) -> (opt AuthnMethodRemoveResponse);
};
